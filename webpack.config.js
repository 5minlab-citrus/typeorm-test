const path = require('path');

const webpack = require('webpack');
const slsw = require('serverless-webpack');
const nodeExternals = require('webpack-node-externals');
const ForkTsCheckerNotifierWebpackPlugin = require('fork-ts-checker-notifier-webpack-plugin');
const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');
const SentryWebpackPlugin = require('@sentry/webpack-plugin');
const CircularDependencyPlugin = require('circular-dependency-plugin');
const isCI = require('is-ci');

const root = path.resolve(__dirname);
const src = path.resolve(root, 'src');

const env = slsw.lib.webpack.isLocal ? 'development' : 'production';

function makePlugins() {
	const plugins = [
		new webpack.ProgressPlugin(),
		new CircularDependencyPlugin({
			// exclude detection of files based on a RegExp
			exclude: /a\.js|node_modules/,
			// include specific files based on a RegExp
			include: /src/,
			// add errors to webpack instead of warnings
			failOnError: true,
			// allow import cycles that include an asyncronous import,
			// e.g. via import(/* webpackMode: "weak" */ './file.js')
			allowAsyncCycles: false,
			// set the current working directory for displaying module paths
			cwd: process.cwd(),

			// `onDetected` is called for each module that is cyclical
			onDetected({ module: webpackModuleRecord, paths, compilation }) {
				// `paths` will be an Array of the relative module paths that make up the cycle
				// `module` will be the module record generated by webpack that caused the cycle

				// entity에서 x-to-x 관계를 본격적으로 쓰면 cycle를 피하기 어렵다
				// UserBattleEntity -> BattleEntity -> UserBattleEntity
				// ClanEntity -> ClanMemberEntity -> ClanEntity
				// 그래서 entity간의 사이클은 무시
				const isEntityCycle = paths.map(x => x.endsWith('Entity.ts')).reduce((a, b) => a && b, true);
				if (isEntityCycle) { return; }

				compilation.errors.push(new Error(paths.join(' -> ')))
			},
		}),
	];

	if (env === 'development') {
		const plugins_development = [
			new ForkTsCheckerWebpackPlugin({
				tslint: false,
				useTypescriptIncrementalApi: true
			}),
			new ForkTsCheckerNotifierWebpackPlugin({
				title: 'TypeScript',
				excludeWarnings: false,
			}),
		]
		for (const p of plugins_development) { plugins.push(p); }
	}

	if (isCI) {
		const plugins_production = [
			new SentryWebpackPlugin({
				include: '.',
				ignoreFile: '.sentrycliignore',
				ignore: ['node_modules', 'webpack.config.js'],
				configFile: 'sentry.properties',
			}),
		];
		for (const p of plugins_production) { plugins.push(p); }
	}

	return plugins;
}

module.exports = {
	mode: env,
	entry: slsw.lib.entries,
	devtool: 'source-map',
	resolve: {
		extensions: ['.js', '.jsx', '.json', '.ts', '.tsx'],
	},
	output: {
		libraryTarget: 'commonjs',
		path: path.join(__dirname, '.webpack'),
		filename: '[name].js',
	},
	target: 'node',
	module: {
		rules: [
			// all files with a `.ts` or `.tsx` extension will be handled by `ts-loader`
			{
				test: /\.tsx?$/,
				include: [src],
				exclude: [/node_modules/],
				use: {
					loader: 'ts-loader',
					// https://webpack.js.org/guides/build-performance/#typescript-loader
					options: {
						transpileOnly: env === 'development' ? true : false,
						experimentalWatchApi: env === 'development' ? true : false,
					},
				},
			},
		],
	},
	node: {
		__dirname: true,
	},
	plugins: makePlugins(),
	externals: [nodeExternals()],
	optimization: {
		minimize: false,
		// https://webpack.js.org/guides/build-performance/#avoid-extra-optimization-steps
		removeAvailableModules: false,
		removeEmptyChunks: false,
		splitChunks: false,
	},
};
